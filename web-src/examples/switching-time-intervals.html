<!DOCTYPE html>
<html lang="en">
  <head>
    <title>dc.js - Switching Time Intervals</title>
    <meta charset="UTF-8" />
    <link rel="stylesheet" type="text/css" href="../css/bootstrap.min.css" />
    <link rel="stylesheet" type="text/css" href="../css/dc.css" />
    <style>
      dl {
        margin-left: 2em;
      }

      #counter-text {
        display: inline;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <div id="header"></div>

      <p>
        This example demonstrates switching between different intervals of
        aggregation over time.
      </p>
      <select id="interval"></select>
      <span style="font-size: large;" id="counter"></span
      ><span id="counter-text" style="display: none;"> selected.</span>
      <br />
      <div id="test" style="min-height: 500px;"></div>

      <script type="text/javascript" src="header.js"></script>
      <script type="text/javascript" src="../js/d3.js"></script>
      <script type="text/javascript" src="../js/crossfilter.js"></script>
      <script type="text/javascript" src="../js/dc-compat.js"></script>
      <script type="text/javascript">
        const defaultInterval = 'Weeks';

        const chart = new dc.BarChart('#test'),
          counter = new dc.NumberDisplay('#counter');

        d3.csv('monthly-move.csv').then(posts => {
          posts.forEach(d => {
            d.date = new Date(d.date);
            d.volume = +d.volume;
          });

          const ndx = crossfilter(posts);
          const dateDim = ndx.dimension(d => d.date);
          let postsGroup;

          const intervals = {
            Days: d3.timeDay,
            Weeks: d3.timeWeek,
            Months: d3.timeMonth,
            Years: d3.timeYear,
          };

          d3.select('#interval')
            .selectAll('option')
            .data(Object.keys(intervals))
            .enter()
            .append('option')
            .text(d => d)
            .attr('selected', d => (d === defaultInterval ? '' : null));

          d3.select('#interval').on('change', () => {
            setupDataProvider();
            dc.redrawAll();
          });

          function setupDataProvider() {
            if (postsGroup) {
              postsGroup.dispose();
            }
            const intervalName = d3.select('#interval').nodes()[0].value;
            const interval = intervals[intervalName];

            postsGroup = dateDim
              .group(k => interval(k))
              .reduce(
                (p, v) => {
                  ++p.count;
                  p.total += v.volume;
                  return p;
                },
                (p, v) => {
                  --p.count;
                  p.total -= v.volume;
                  return p;
                },
                () => ({
                  count: 0,
                  total: 0,
                })
              );

            chart
              .dimension(dateDim)
              .group(postsGroup)
              .valueAccessor(kv => kv.value.total)
              .xUnits(interval.range)
              .transitionDuration(postsGroup.all().length > 2000 ? 0 : 1000);

            console.log(`Setup for ${intervalName}completed.`);
          }

          chart
            .width(768)
            .height(480)
            .x(d3.scaleTime())
            .xUnits(d3.timeWeeks)
            .margins({ left: 50, top: 0, right: 0, bottom: 20 })
            .elasticX(true)
            .elasticY(true)
            .clipPadding(10);
          chart.yAxis().tickFormat(d3.format('.3s'));

          setupDataProvider();

          const groupAll = ndx.groupAll().reduceSum(d => d.volume);

          counter
            .dimension({})
            .group(groupAll)
            .valueAccessor(x => x);

          dc.renderAll();
        });
      </script>
    </div>
  </body>
</html>
