<!DOCTYPE html>
<html lang="en">
<head>
    <title>dc.js - Row Chart Example</title>
    <meta charset="UTF-8">
    <link rel="stylesheet" type="text/css" href="../css/bootstrap.min.css">
    <link rel="stylesheet" type="text/css" href="../css/dc.css"/>

    <style>
      /* body { */
      /*   font-size: 10px; */
      /*   font-family: 'Open Sans', sans-serif; */
      /*   font-weight: 400; */
      /*   text-align: center; */
      /* } */

      /* #title { */
      /*     font-size: 20px; */
      /*     padding-bottom: 10px; */
      /*     padding-top: 20px; */
      /*     font-weight: 300; */
      /* } */

      /* #explanation { */
      /*     font-size: 12px; */
      /*     max-width: 620px; */
      /*     margin: 0 auto; */
      /*     padding-top: 10px; */
      /*     color: #ababab; */
      /*     font-weight: 300; */
      /* } */

      .y.axis line {
      fill: none;
      }

      .x.axis line {
          fill: none;
          stroke: #e0e0e0;
          shape-rendering: crispEdges;
      }

      .axis path {
          display: none;
      }

      .brush .extent {
          fill-opacity: .125;
          shape-rendering: crispEdges;
      }

      .resize {
          display: inline !important; /* show when empty */
          fill: #7A7A7A;
          fill-opacity: 1;
          stroke: #7A7A7A;
          stroke-width: 2px;
      }

      .bar {
          /*shape-rendering: crispEdges;*/
      }
    </style>

</head>
<body>

<div class="container">
  <script type="text/javascript" src="header.js"></script>
  <p>Example of connecting an external D3 chart with dc.js, adapting the code from
    Nadieh Bremer's <a href="http://bl.ocks.org/nbremer/4c015860931fb6a13afc7bac51f40b43">Brushable Horizontal Bar Chart - V</a>.</p>
  <p>Thanks Nadieh for permission to use this code! See her <a href="http://www.visualcinnamon.com/2016/07/brush-bar-chart-d3.html">mini-blog about the example</a>.</p>
  <p>This chart has often been requested (<a href="https://github.com/dc-js/dc.js/issues/1259">dc-js/dc.js#1259</a>) and should serve as a general example of how to connect an external chart.</p>
<div id="first-letters"></div>
<div id="brushable-bar"></div>

<script type="text/javascript" src="../js/d3.js"></script>
<script type="text/javascript" src="../js/crossfilter.js"></script>
<script type="text/javascript" src="../js/dc.js"></script>

<script type="text/javascript">


  // steps for adapting Nadieh's code to dc.js:
  // - wrap in a chart class
  // - init() becomes render(), update() becomes redraw()
  // - globals become class members
  // - port from d3@3 to d3@6
  // - translate to ES6 where useful
  // - data comes from this._group.all(), which returns array of {key,value}
  // - add accessors and use inputs

  class BrushableHorizontalBarChart {
      _group = null;
      _root = null;
      _svg = null;
      _defs = null;
      _gBrush = null;
      _brush = null;
      _main_xScale = null;
      _mini_xScale = null;
      _main_yScale = null;
      _mini_yScale = null;
      _main_yZoom = null;
      _main_xAxis = null;
      _main_yAxis = null;
      _mini_width = null;
      _textScale = null;

      constructor(parent, group) {
          this._group = null;
          this._root = d3.select(parent);
          dc.registerChart(this, group);
      }

      // initialization functions for user

      group(group) {
          if(!arguments.length)
              return this._group;
          this._group = group;
          return this;
      }

      render() {
          // code from function init() from the bl.ock
          //Added only for the mouse wheel
          var zoomer = d3.zoom()
              .on("zoom", null);

          var main_margin = {top: 10, right: 10, bottom: 30, left: 100},
              main_width = 500 - main_margin.left - main_margin.right,
              main_height = 400 - main_margin.top - main_margin.bottom;

          var mini_margin = {top: 10, right: 10, bottom: 30, left: 10},
              mini_height = 400 - mini_margin.top - mini_margin.bottom;
          this._mini_width = 100 - mini_margin.left - mini_margin.right;

          this._svg = this._root.append("svg")
              .attr("class", "svgWrapper")
              .attr("width", main_width + main_margin.left + main_margin.right + this._mini_width + mini_margin.left + mini_margin.right)
              .attr("height", main_height + main_margin.top + main_margin.bottom)
              .call(zoomer)
              .on("wheel.zoom", scroll)
          //.on("mousewheel.zoom", scroll)
          //.on("DOMMouseScroll.zoom", scroll)
          //.on("MozMousePixelScroll.zoom", scroll)
          //Is this needed?
              .on("mousedown.zoom", null)
              .on("touchstart.zoom", null)
              .on("touchmove.zoom", null)
              .on("touchend.zoom", null);

          var mainGroup = this._svg.append("g")
              .attr("class","mainGroupWrapper")
              .attr("transform","translate(" + main_margin.left + "," + main_margin.top + ")")
              .append("g") //another one for the clip path - due to not wanting to clip the labels
              .attr("clip-path", "url(#clip)")
              .style("clip-path", "url(#clip)")
              .attr("class","mainGroup");

          var miniGroup = this._svg.append("g")
              .attr("class","miniGroup")
              .attr("transform","translate(" + (main_margin.left + main_width + main_margin.right + mini_margin.left) + "," + mini_margin.top + ")");

          var brushGroup = this._svg.append("g")
              .attr("class","brushGroup")
              .attr("transform","translate(" + (main_margin.left + main_width + main_margin.right + mini_margin.left) + "," + mini_margin.top + ")");

          /////////////////////////////////////////////////////////////
          ////////////////////// Initiate scales //////////////////////
          /////////////////////////////////////////////////////////////

          this._main_xScale = d3.scaleLinear().range([0, main_width]);
          this._mini_xScale = d3.scaleLinear().range([0, this._mini_width]);

          this._main_yScale = d3.scaleBand()
              .range([0, main_height])
              .padding(0.4)
              .paddingOuter(0);
          this._mini_yScale = d3.scaleBand()
              .range([0, mini_height])
              .padding(0.4)
              .paddingOuter(0);


          //Based on the idea from: http://stackoverflow.com/questions/21485339/d3-brushing-on-grouped-bar-chart
          this._main_yZoom = d3.scaleLinear()
              .range([0, main_height])
              .domain([0, main_height]);

          //Create x axis object
          this._main_xAxis = d3.axisBottom()
              .scale(this._main_xScale)
              .ticks(4)
          //.tickSize(0)
              .tickSizeOuter(0);

          //Add group for the x axis
          d3.select(".mainGroupWrapper")
              .append("g")
              .attr("class", "x axis")
              .attr("transform", "translate(" + 0 + "," + (main_height + 5) + ")");

          //Create y axis object
          this._main_yAxis = d3.axisLeft()
              .scale(this._main_yScale)
              .tickSize(0)
              .tickSizeOuter(0);

          //Add group for the y axis
          mainGroup.append("g")
              .attr("class", "y axis")
              .attr("transform", "translate(-5,0)");

          /////////////////////////////////////////////////////////////
          /////////////////////// Update scales ///////////////////////
          /////////////////////////////////////////////////////////////

          //Update the scales
          const data = this._group.all();
          this._main_xScale.domain([0, d3.max(data, function(d) { return d.value; })]);
          this._mini_xScale.domain([0, d3.max(data, function(d) { return d.value; })]);
          this._main_yScale.domain(data.map(function(d) { return d.key; }));
          this._mini_yScale.domain(data.map(function(d) { return d.key; }));

          //Create the visual part of the y axis
          d3.select(".mainGroup").select(".y.axis").call(this._main_yAxis);

          /////////////////////////////////////////////////////////////
          ///////////////////// Label axis scales /////////////////////
          /////////////////////////////////////////////////////////////

          this._textScale = d3.scaleLinear()
              .domain([15,50])
              .range([12,6])
              .clamp(true);

          /////////////////////////////////////////////////////////////
          ///////////////////////// Create brush //////////////////////
          /////////////////////////////////////////////////////////////

          //What should the first extent of the brush become - a bit arbitrary this
          var brushExtent = Math.max( 1, Math.min( 20, Math.round(data.length*0.2) ) );

          this._brush = d3.brushY()
              //.y(this._mini_yScale)
              .extent([this._mini_yScale(data[0].key), this._mini_yScale(data[brushExtent].key)])
              .on("brush", this.brushmove.bind(this))
          //.on("brushend", brushend);

          //Set up the visual part of the brush
          this._gBrush = d3.select(".brushGroup").append("g")
              .attr("class", "brush")
              .call(this._brush);

          this._gBrush.selectAll(".resize")
              .append("line")
              .attr("x2", this._mini_width);

          this._gBrush.selectAll(".resize")
              .append("path")
              .attr("d", d3.symbol().type("triangle-up").size(20))
              .attr("transform", function(d,i) {
                  return i ? "translate(" + (this._mini_width/2) + "," + 4 + ") rotate(180)" : "translate(" + (this._mini_width/2) + "," + -4 + ") rotate(0)";
              });

          this._gBrush.selectAll("rect")
              .attr("width", this._mini_width);

          //On a click recenter the brush window
          this._gBrush.select(".background")
              .on("mousedown.brush", this.brushcenter.bind(this))
              .on("touchstart.brush", this.brushcenter.bind(this));

          ///////////////////////////////////////////////////////////////////////////
          /////////////////// Create a rainbow gradient - for fun ///////////////////
          ///////////////////////////////////////////////////////////////////////////

          this._defs = this._svg.append("defs")

          //Create two separate gradients for the main and mini bar - just because it looks fun
          this.createGradient("gradient-rainbow-main", "60%");
          this.createGradient("gradient-rainbow-mini", "13%");

          //Add the clip path for the main bar chart
          this._defs.append("clipPath")
              .attr("id", "clip")
              .append("rect")
              .attr("x", -main_margin.left)
              .attr("width", main_width + main_margin.left)
              .attr("height", main_height);

          /////////////////////////////////////////////////////////////
          /////////////// Set-up the mini bar chart ///////////////////
          /////////////////////////////////////////////////////////////

          //The mini brushable bar
          //DATA JOIN
          var mini_bar = d3.select(".miniGroup").selectAll(".bar")
              .data(data, function(d) { return d.key; });

          //UDPATE
          mini_bar
              .attr("width", ({value}) => this._mini_xScale(value))
              .attr("y", ({key}) => this._mini_yScale(key))
              .attr("height", this._mini_yScale.bandwidth());

          //ENTER
          mini_bar.enter().append("rect")
              .attr("class", "bar")
              .attr("x", 0)
              .attr("width", ({value}) => this._mini_xScale(value))
              .attr("y", ({key}) => this._mini_yScale(key))
              .attr("height", this._mini_yScale.bandwidth())
              .style("fill", "url(#gradient-rainbow-mini)");

          //EXIT
          mini_bar.exit()
              .remove();

          //Start the brush
          this._gBrush.call(this._brush);
      }//render
      redraw() {
          // code from function update() from the block
          /////////////////////////////////////////////////////////////
          ////////// Update the bars of the main bar chart ////////////
          /////////////////////////////////////////////////////////////

          //DATA JOIN
          var bar = d3.select(".mainGroup").selectAll(".bar")
              .data(data, function(d) { return d.key; });

          //UPDATE
          bar
              .attr("y", ({key}) => this._main_yScale(key))
              .attr("height", this._main_yScale.rangeBand())
              .attr("x", 0)
              .transition().duration(50)
              .attr("width", function(d) { return this._main_xScale(d.value); });

          //ENTER
          bar.enter().append("rect")
              .attr("class", "bar")
              .style("fill", "url(#gradient-rainbow-main)")
              .attr("y", ({key}) => this._main_yScale(key))
              .attr("height", this._main_yScale.rangeBand())
              .attr("x", 0)
              .transition().duration(50)
              .attr("width", function(d) { return this._main_xScale(d.value); });

          //EXIT
          bar.exit()
              .remove();
          // not yet implemented: will need new
      }//redraw

      brushmove() {

          var extent = this._brush.extent();

          //Which bars are still "selected"
          var selected = this._mini_yScale.domain()
              .filter(function(d) { return (extent[0] - this._mini_yScale.rangeBand() + 1e-2 <= this._mini_yScale(d)) && (this._mini_yScale(d) <= extent[1] - 1e-2); });
          //Update the colors of the mini chart - Make everything outside the brush grey
          d3.select(".miniGroup").selectAll(".bar")
              .style("fill", function(d, i) { return selected.indexOf(d.key) > -1 ? "url(#gradient-rainbow-mini)" : "#e0e0e0"; });

          //Update the label size
          d3.selectAll(".y.axis text")
              .style("font-size", this._textScale(selected.length));

          /////////////////////////////////////////////////////////////
          ///////////////////// Update the axes ///////////////////////
          /////////////////////////////////////////////////////////////

          //Reset the part that is visible on the big chart
          var originalRange = this._main_yZoom.range();
          this._main_yZoom.domain( extent );

          //Update the domain of the x & y scale of the big bar chart
          this._main_yScale.domain(data.map(function(d) { return d.key; }));
          this._main_yScale.range( [ this._main_yZoom(originalRange[0]), this._main_yZoom(originalRange[1]) ], 0.4, 0);

          //Update the y axis of the big chart
          d3.select(".mainGroup")
              .select(".y.axis")
              .call(this._main_yAxis);

          //Find the new max of the bars to update the x scale
          var newMaxXScale = d3.max(data, function(d) { return selected.indexOf(d.key) > -1 ? d.value : 0; });
          this._main_xScale.domain([0, newMaxXScale]);

          //Update the x axis of the big chart
          d3.select(".mainGroupWrapper")
              .select(".x.axis")
              .transition().duration(50)
              .call(this._main_xAxis);

          //Update the big bar chart
          update();

      }//brushmove

      /////////////////////////////////////////////////////////////
      ////////////////////// Click functions //////////////////////
      /////////////////////////////////////////////////////////////

      //Based on http://bl.ocks.org/mbostock/6498000
      //What to do when the user clicks on another location along the brushable bar chart
      brushcenter() {
          var target = d3.event.target,
              extent = this._brush.extent(),
              size = extent[1] - extent[0],
              range = this._mini_yScale.range(),
              y0 = d3.min(range) + size / 2,
              y1 = d3.max(range) + this._mini_yScale.rangeBand() - size / 2,
              center = Math.max( y0, Math.min( y1, d3.mouse(target)[1] ) );

          d3.event.stopPropagation();

          this._gBrush
              .call(this._brush.extent([center - size / 2, center + size / 2]))
              .call(this._brush.event);

      }//brushcenter

      /////////////////////////////////////////////////////////////
      ///////////////////// Scroll functions //////////////////////
      /////////////////////////////////////////////////////////////

      scroll() {

          //Mouse scroll on the mini chart
          var extent = this._brush.extent(),
              size = extent[1] - extent[0],
              range = this._mini_yScale.range(),
              y0 = d3.min(range),
              y1 = d3.max(range) + this._mini_yScale.rangeBand(),
              dy = d3.event.deltaY,
              topSection;

          if ( extent[0] - dy < y0 ) { topSection = y0; }
          else if ( extent[1] - dy > y1 ) { topSection = y1 - size; }
          else { topSection = extent[0] - dy; }

          //Make sure the page doesn't scroll as well
          d3.event.stopPropagation();
          d3.event.preventDefault();

          this._gBrush
              .call(this._brush.extent([ topSection, topSection + size ]))
              .call(this._brush.event);

      }//scroll
      //Create a gradient
      createGradient(idName, endPerc) {

          var coloursRainbow = ["#EFB605", "#E9A501", "#E48405", "#E34914", "#DE0D2B", "#CF003E", "#B90050", "#A30F65", "#8E297E", "#724097", "#4F54A8", "#296DA4", "#0C8B8C", "#0DA471", "#39B15E", "#7EB852"];

          this._defs.append("linearGradient")
              .attr("id", idName)
              .attr("gradientUnits", "userSpaceOnUse")
              .attr("x1", "0%").attr("y1", "0%")
              .attr("x2", endPerc).attr("y2", "0%")
              .selectAll("stop")
              .data(coloursRainbow)
              .enter().append("stop")
              .attr("offset", function(d,i) { return i/(coloursRainbow.length-1); })
              .attr("stop-color", function(d) { return d; });
      }//createGradient
  }//BrushableHorizontalBarChart


  d3.json("wide-ordinal.json").then(function(wide) {
      var cf = crossfilter(wide);

      // display a row chart of first letters, to test filtering
      var letterDimension = cf.dimension(function(d) {
          return d.key.split(' ').map(function(s) { return s[0]; });
      }, true);
      var letterGroup = letterDimension.group();
      var bar = new dc.BarChart('#first-letters');
      bar
          .width(1000)
          .height(250)
          .gap(1)
          .x(d3.scaleBand())
          .xUnits(dc.units.ordinal)
          .dimension(letterDimension)
          .group(letterGroup);

      var phraseDim = cf.dimension(({key}) => key),
          phraseGroup = phraseDim.group().reduceSum(({value}) => value);

      var brushable = new BrushableHorizontalBarChart('#brushable-bar');
      brushable.group(phraseGroup);

      dc.renderAll();
  });
</script>

</div>
</body>
</html>
