<!DOCTYPE html>
<html lang="en">
<head>
    <title>dc.js - Right Axis Example</title>
    <meta charset="UTF-8">
    <link rel="stylesheet" type="text/css" href="../css/bootstrap.min.css">
    <link rel="stylesheet" type="text/css" href="../css/dc.css"/>
</head>
<body>

<div class="container">
<script type="text/javascript" src="header.js"></script>
<div>
    <strong>Monthly Index Abs Move &amp; Volume Chart</strong>
</div>
<div id="monthly-move-chart"></div>

<script type="text/javascript" src="../js/d3.js"></script>
<script type="text/javascript" src="../js/crossfilter.js"></script>
<script type="text/javascript" src="../js/dc.js"></script>
<script type="text/javascript">
    const moveChart = new dc.CompositeChart("#monthly-move-chart");

    d3.csv("monthly-move.csv").then((data) => {
    const dateFormatSpecifier = "%m/%d/%Y";
    const dateFormat = d3.timeFormat(dateFormatSpecifier);
    const dateFormatParser = d3.timeParse(dateFormatSpecifier);
    const numberFormat = d3.format(".2f");

    data.forEach((e) => {
    e.dd = dateFormatParser(e.date);
    e.month = d3.timeMonth(e.dd); // pre-calculate month for better performance
});

    const ndx = crossfilter(data);
    // monthly index avg fluctuation in percentage
    const moveMonths = ndx.dimension((d) => d.month);
    const monthlyMoveGroup = moveMonths.group().reduceSum((d) => Math.abs(+d.close - +d.open));
    const indexAvgByMonthGroup = moveMonths.group().reduce(
            (p, v) => {
            ++p.days;
            p.total += (+v.open + +v.close) / 2;
            p.avg = Math.round(p.total / p.days);
            return p;
        },
            (p, v) => {
            --p.days;
            p.total -= (+v.open + +v.close) / 2;
            p.avg = (p.days === 0) ? 0 : Math.round(p.total / p.days);
            return p;
        },
            () => ({days: 0, total: 0, avg: 0})
    );

    moveChart.width(600)
            .height(300)
            .transitionDuration(1000)
            .margins({top: 30, right: 50, bottom: 25, left: 60})
            .dimension(moveMonths)
            .mouseZoomable(true)
            .shareTitle(false)
            .x(d3.scaleTime().domain([new Date(1985, 0, 1), new Date(2012, 11, 31)]))
            .round(d3.timeMonth.round)
            .xUnits(d3.timeMonths)
            .elasticY(true)
            .renderHorizontalGridLines(true)
            .legend(dc.legend().x(70).y(10).itemHeight(13).gap(5))
            .brushOn(false)
            .compose([
                new dc.LineChart(moveChart)
                        .group(indexAvgByMonthGroup, "Monthly Index Average")
                        .valueAccessor((d) => d.value.avg),
                new dc.LineChart(moveChart)
                        .group(monthlyMoveGroup, "Monthly Index Move")
                        .valueAccessor((d) => Math.sqrt(d.value))
                        .title((d) => {
                        let value = d.value.avg ? d.value.avg : d.value;
                        if (isNaN(value)) {value = 0;}
                        return `${dateFormat(d.key)  }\n${  numberFormat(value)}`;
                    })
                        .ordinalColors(["orange"])
                        .useRightYAxis(true)
            ])
            .yAxisLabel("Monthly Index Average")
            .rightYAxisLabel("Monthly Index Move")
            .renderHorizontalGridLines(true);

    dc.renderAll();
});
</script>
</div>
</body>
</html>
